module testingModule;

import cz.muni.fi.sbapr.debs2014.annotation.*;
import cz.muni.fi.sbapr.debs2014.event.*;
import cz.muni.fi.sbapr.debs2014.subscriber.*;
import cz.muni.fi.sbapr.debs2014.listener.*;

@Name('SegmentedByHouse')
create context SegmentedByHouse partition by houseId from SensorEvent;

@Name('SegmentedByHousehold')
create context SegmentedByHousehold partition by houseId and householdId from SensorEvent;

@Name('SegmentedByPlug')
create context SegmentedByPlug partition by houseId and householdId and plugId from SensorEvent;

@Name('NestedContext')
create context NestedContext
    context SegmentedByHouse partition by houseId from SensorEvent,
    context SegmentedByHousehold partition by householdId from SensorEvent,
    context SegmentedByPlug partition by plugId from SensorEvent;

@Name('RuntimeReportingStatement')
select current_timestamp() as runtime
from pattern [every timer:interval(1 sec)];

@Name('SensorEventReportingStatement')
select * from SensorEvent;



//@Name('ActivePlugCount')
//context SegmentedByHouse create variable integer plugCount = 0;

//@Name('HousePlugCountIncrementStatement')
//context SegmentedByHouse
//on pattern[every-distinct(e.houseId, e.householdId, e.plugId) e=SensorEvent]
//set plugCount = plugCount + 1;

//@Name('HousePlugCountStream')
//context SegmentedByHouse
//select houseId, plugCount as activePlugCount 
//context.key1 as house, context.key2 as household, context.key3 as plug 
//from SensorEvent
//;



@Name('OverPlugCount')
context SegmentedByHouse create variable integer overPlugCount = 0;

//@Name('HouseOverPlugCountIncrementStatement')
//context SegmentedByHouse
//on pattern[every-distinct(e.houseId, e.householdId, e.plugId) e=SensorEvent]
//set plugCount = plugCount + 1;

@Name('GlobalLoadAverageStatement')
select 
    avg(value.doubleValue()) as globalLoadAverage, 
    timestamp as ts_start,
    timestamp.minus(1*60) as ts_stop
from SensorEvent(property = true).win:time(1 min);

@Name('PlugLoadAverageStatement')
//context SegmentedByPlug
select 
    //context.key1 as house, 
    //context.key2 as household, 
    //context.key3 as plug,
    plugId, householdId, houseId,
    avg(value.doubleValue()) as plugLoadAverage, 
    timestamp as ts_start,
    timestamp.minus(1*60) as ts_stop
from SensorEvent(property = true).win:time(1 min)
group by houseId, householdId, plugId
;




//@Name('TestStatement')
//context SegmentedByHouse
//select houseId, plugCount as activePlugCount 
//context.key1 as house, context.key2 as household, context.key3 as plug 
//from SensorEvent
//;

//@Name('TestWindow')
//context SegmentedByPlug
//create window 
//    TestWindow.std:unique(context.id)
//as select * from SensorEvent;

//@Name('TestWindow-populate')
//insert into TestWindow select * from SensorEvent;

//@Name('TestWindowStatement')
//select houseId, count(distinct plugId)
//from TestWindow
//group by houseId, householdId
//output snapshot every 10 events
//;

//@Name('NewPlugStream')
//context SegmentedByPlug
//insert into NewPlugStream
//select * from SensorEvent.std:firstunique(houseId, householdId, plugId);

//@Name('HousePlugCountIncrementStatement')
//context SegmentedByHouse
//on NewPlugStream
//set plugCount = plugCount + 1;

//.win:length(5)
//.std:groupwin(plugId, householdId, houseId).std:unique(houseId)                

//  select * from pattern[every-distinct(s.device) s=Sensor]
//  http://esper.codehaus.org/tutorials/solution_patterns/solution_patterns.html



